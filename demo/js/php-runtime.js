var phpRuntime = "<?php\ndefine(\"LOCAL_TZ\", \"CDT\");\n\nfunction js_void() {}\n\n/**\n * @param Func $fn\n * @return Object\n */\nfunction js_new($fn) {\n  if (property_exists($fn, 'instantiate')) {\n    $instantiate = $fn->instantiate;\n    $obj = $instantiate();\n  } else {\n    $obj = new Object();\n    $obj->setProto($fn->get('prototype'));\n  }\n  $args = array_slice(func_get_args(), 1);\n  $result = $fn->apply($obj, $args);\n  return is_primitive($result) ? $obj : $result;\n}\n\n/**\n * @param Object $obj\n * @param Func $fn\n * @return bool\n */\nfunction js_instanceof($obj, $fn) {\n  $proto = $obj->getProto();\n  $prototype = $fn->get('prototype');\n  while ($proto !== null) {\n    if ($proto === $prototype) {\n      return true;\n    }\n    $proto = $proto->getProto();\n  }\n  return false;\n}\n\nfunction js_plus($a, $b) {\n  //todo: to_primitive() [object -> string]\n  if (gettype($a) === 'string' || gettype($a) === 'string') {\n    return to_string($a) . to_string($b);\n  }\n  //todo: to_number()\n  return $a + $b;\n}\n\nfunction js_and($a, $b) {\n  return $a ? $b : $a;\n}\n\nfunction js_or($a, $b) {\n  return $a ? $a : $b;\n}\n\nfunction js_typeof($value) {\n  if ($value === null) {\n    return 'undefined';\n  }\n  //js weirdness\n  if ($value === Null::$null) {\n    return 'object';\n  }\n  if ($value === NaN::$nan) {\n    return 'number';\n  }\n  $type = gettype($value);\n  if ($type === 'integer' || $type === 'double') {\n    return 'number';\n  }\n  if ($type === 'string' || $type === 'boolean') {\n    return $type;\n  }\n  if ($value instanceof Object) {\n    return $value->type;\n  }\n  return 'unknown';\n}\n\n\nfunction is_primitive($value) {\n  return ($value === null || is_scalar($value) || $value === Null::$null || $value === NaN::$nan);\n}\n\nfunction is_int_or_float($value) {\n  return (is_int($value) || is_float($value));\n}\n\nfunction to_string($value) {\n  if ($value === null) {\n    return 'undefined';\n  }\n  if ($value === Null::$null) {\n    return 'null';\n  }\n  $type = gettype($value);\n  if ($type === 'string') {\n    return $value;\n  }\n  if ($type === 'boolean') {\n    return $value ? 'true' : 'false';\n  }\n  if ($type === 'integer' || $type === 'double') {\n    if (is_nan($value)) return 'NaN';\n    if ($value === INF) return 'Infinity';\n    if ($value === -INF) return '-Infinity';\n    return $value . '';\n  }\n  if ($value === NaN::$nan) {\n    return 'NaN';\n  }\n  if ($value instanceof Object) {\n    $fn = $value->get('toString');\n    if ($fn instanceof Func) {\n      return $fn->call($value);\n    } else {\n      throw new Exception('TypeError: Cannot convert object to primitive value');\n    }\n  }\n  throw new Exception('Cannot cast PHP value to string: ' . _stringify($value));\n}\n\nfunction to_number($value) {\n  if ($value === null) {\n    return NaN::$nan;\n  }\n  if ($value === Null::$null) {\n    return 0.0;\n  }\n  if ($value === NaN::$nan) {\n    return NaN::$nan;\n  }\n  if (is_int_or_float($value)) {\n    return is_nan($value) ? NaN::$nan : (float)$value;\n  }\n  if (is_bool($value)) {\n    return ($value ? 1.0 : 0.0);\n  }\n  if ($value instanceof Object) {\n    return to_number(to_primitive($value));\n  }\n  //trim whitespace\n  $value = preg_replace('/^[\\\\t\\\\x0B\\\\f \\\\xA0\\\\r\\\\n]+|[\\\\t\\\\x0B\\\\f \\\\xA0\\\\r\\\\n]+$/', '', $value);\n  if ($value === '') {\n    return 0.0;\n  }\n  if ($value === 'Infinity' || $value === '+Infinity') {\n    return INF;\n  }\n  if ($value === '-Infinity') {\n    return -INF;\n  }\n  if (preg_match('/^([+-]?)(\\d+\\.\\d*|\\.\\d+|\\d+)$/i', $value)) {\n    return (float)$value;\n  }\n  if (preg_match('/^([+-]?)(\\d+\\.\\d*|\\.\\d+|\\d+)e([+-]?[0-9]+)$/i', $value, $m)) {\n    return catch_nan(pow($m[1] . $m[2], $m[3]));\n  }\n  if (preg_match('/^0x[a-z0-9]+$/i', $value)) {\n    return (float)hexdec(substr($value, 2));\n  }\n  return NaN::$nan;\n}\n\n//used in to_number to handle objects\nfunction to_primitive($obj) {\n  $value = $obj->callMethod('valueOf');\n  if ($value instanceof Object) {\n    $value = to_string($value);\n  }\n  return $value;\n}\n\n//used in math functions to ensure we don't ever get PHP's NAN\nfunction catch_nan($num) {\n  return is_nan($num) ? NaN::$nan : (float)$num;\n}\n\n//used to get/set properties on primitives\nfunction objectify($value) {\n  $type = gettype($value);\n  if ($type === 'string') {\n    return new Str($value);\n  } elseif ($type === 'integer' || $type === 'double') {\n    return new Number($value);\n  } elseif ($type === 'boolean') {\n    return new Bln($value);\n  }\n  return $value;\n}\n\n\n//getters, setters and function callers\nfunction get($obj, $name) {\n  if ($obj === null || $obj === Null::$null) {\n    throw new Exception(\"TypeError: Cannot read property '$name' of \" . to_string($obj));\n  }\n  $obj = objectify($obj);\n  return $obj->get($name);\n}\n\nfunction set($obj, $name, $value) {\n  if ($obj === null || $obj === Null::$null) {\n    throw new Exception(\"TypeError: Cannot set property '$name' of \" . to_string($obj));\n  }\n  $obj = objectify($obj);\n  return $obj->set($name, $value);\n}\n\nfunction call($fn) {\n  if (!($fn instanceof Func)) {\n    throw new Exception(\"TypeError: \" . js_typeof($fn) . \" is not a function\");\n  }\n  $args = array_slice(func_get_args(), 1);\n  return $fn->apply(Object::$global, $args);\n}\n\nfunction call_method($obj, $name) {\n  if ($obj === null || $obj === Null::$null) {\n    throw new Exception(\"TypeError: Cannot read property '$name' of \" . to_string($obj));\n  }\n  $obj = objectify($obj);\n  $fn = $obj->get($name);\n  if (!($fn instanceof Func)) {\n    throw new Exception(\"TypeError: \" . js_typeof($fn) . \" is not a function\");\n  }\n  $args = array_slice(func_get_args(), 2);\n  return $fn->apply($obj, $args);\n}\n\nclass Null extends SimpleXmlElement {\n  static $null = null;\n}\nNull::$null = new Null('<false/>');\n\nclass NaN extends SimpleXmlElement {\n  static $nan = null;\n}\nNaN::$nan = new NaN('<false/>');\n\nclass Object implements JsonSerializable {\n  public $data = null;\n  public $proto = null;\n  public $type = \"object\";\n  public $className = \"[object Object]\";\n\n  static $protoObject = null;\n  static $global = null;\n\n  function __construct() {\n    $this->data = new StdClass();\n    $this->setProto(self::$protoObject);\n    $args = func_get_args();\n    if (count($args) > 0) {\n      $this->_init($args);\n    }\n  }\n\n  function _init($arr) {\n    $len = count($arr);\n    for ($i = 0; $i < $len; $i += 2) {\n      $this->set($arr[$i], $arr[$i + 1]);\n    }\n  }\n\n  function get($key) {\n    if (method_exists($this, 'get_' . $key)) {\n      return $this->{'get_' . $key}();\n    }\n    $obj = $this;\n    while ($obj !== null) {\n      $data = $obj->data;\n      if (property_exists($data, $key)) {\n        return $data->{$key}->value;\n      }\n      $obj = $obj->proto;\n    }\n    return null;\n  }\n\n  function set($key, $value) {\n    if (method_exists($this, 'set_' . $key)) {\n      return $this->{'set_' . $key}($value);\n    }\n    $data = $this->data;\n    if (property_exists($data, $key)) {\n      $data->{$key}->value = $value;\n    } else {\n      $data->{$key} = new Property($value);\n    }\n    return $value;\n  }\n\n  function setProperty($key, $value, $writable, $enumerable, $configurable) {\n    $data = $this->data;\n    if (property_exists($data, $key)) {\n      $prop = $data->{$key};\n      $prop->value = $value;\n      if ($writable !== null) $prop->writable = $writable;\n      if ($enumerable !== null) $prop->enumerable = $enumerable;\n      if ($configurable !== null) $prop->configurable = $configurable;\n    } else {\n      $data->{$key} = new Property($value, $writable, $enumerable, $configurable);\n    }\n    return $value;\n  }\n\n  /**\n   * @return Object\n   */\n  function getProto() {\n    return $this->proto;\n  }\n\n  /**\n   * @param Object $obj\n   * @return Object\n   */\n  function setProto($obj) {\n    return $this->proto = $obj;\n  }\n\n  /**\n   * @param array $props\n   */\n  function setProps($props) {\n    foreach ($props as $key => $value) {\n      $this->set($key, $value);\n    }\n  }\n\n  /**\n   * @param array $methods\n   */\n  function setMethods($methods) {\n    foreach ($methods as $key => $fn) {\n      $this->set($key, new Func($fn));\n    }\n  }\n\n  /**\n   * @param string $name\n   * @return mixed\n   */\n  function callMethod($name) {\n    /** @var Func $fn */\n    $fn = $this->get($name);\n    $args = array_slice(func_get_args(), 1);\n    return $fn->apply($this, $args);\n  }\n\n  /**\n   * @return StdClass\n   */\n  function jsonSerialize() {\n    $results = new StdClass();\n    foreach ($this->data as $key => $prop) {\n      if ($prop->enumerable) {\n        $results->{$key} = $prop->value;\n      }\n    }\n    return $results;\n  }\n\n  static function initProtoObject() {\n    $protoProps = array(\n      'hasOwnProperty' => function($this_, $arguments, $key) {\n          return property_exists($this_->data, $key);\n        },\n      'toString' => function($this_) {\n          return $this_->className;\n        },\n      'valueOf' => function($this_) {\n          return $this_;\n        }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setProps($protoProps);\n  }\n\n  static function initProtoMethods() {\n    $data = self::$protoObject->data;\n    foreach ($data as $key => $prop) {\n      if ($prop->value instanceof Closure) {\n        $prop->value = new Func($prop->value);\n      }\n    }\n  }\n}\n\nclass Property {\n  public $value = null;\n  public $writable = true;\n  public $enumerable = true;\n  public $configurable = true;\n\n  function __construct($value, $writable = true, $enumerable = true, $configurable = true) {\n    $this->value = $value;\n    $this->writable = $writable;\n    $this->enumerable = $enumerable;\n    $this->configurable = $configurable;\n  }\n\n  /**\n   * @return Object\n   */\n  function getDescriptor() {\n    $result = new Object();\n    $result->set('value', $this->value);\n    $result->set('writable', $this->writable);\n    $result->set('enumerable', $this->enumerable);\n    $result->set('configurable', $this->configurable);\n    return $result;\n  }\n}\n\nObject::initProtoObject();\n\nclass Func extends Object {\n  public $name = \"\";\n  public $type = \"function\";\n  public $className = \"[object Function]\";\n\n  function __construct() {\n    parent::__construct();\n    $args = func_get_args();\n    if (count($args) === 2) {\n      $this->name = $args[0];\n      $this->fn = $args[1];\n    } else {\n      $this->fn = $args[0];\n    }\n    $prototype = new Object('constructor', $this);\n    $this->set('prototype', $prototype);\n  }\n\n  function construct() {\n    if (property_exists($this, 'instantiate')) {\n      $instantiate = $this->instantiate;\n      $obj = $instantiate();\n    } else {\n      $obj = new Object();\n      $obj->setProto($this->get('prototype'));\n    }\n    $result = $this->apply($obj, func_get_args());\n    return is_primitive($result) ? $obj : $result;\n  }\n\n  function call($context = null) {\n    if (func_num_args() === 0) {\n      $context = Object::$global;\n    }\n    $args = array_slice(func_get_args(), 1);\n    array_unshift($args, self::makeArgs($args, $this));\n    array_unshift($args, $context);\n    return call_user_func_array($this->fn, $args);\n  }\n\n  function apply($context, $args) {\n    array_unshift($args, self::makeArgs($args, $this));\n    array_unshift($args, $context);\n    return call_user_func_array($this->fn, $args);\n  }\n\n  function get_name() {\n    return $this->name;\n  }\n\n  function set_name($value) {\n    return $value;\n  }\n\n  static function makeArgs($args, $callee) {\n    $obj = new Object();\n    $obj->args = $args;\n    $len = count($args);\n    for ($i = 0; $i < $len; $i++) {\n      $obj->set($i, $args[$i]);\n    }\n    $obj->set('length', (float)$len);\n    $obj->data->callee = new Property($callee, true, false, true);\n    return $obj;\n  }\n}\n\nObject::initProtoMethods();\n\nclass GlobalObject extends Object {\n\n  function set($key, $value) {\n    throw new Exception('Cannot mutate global object');\n  }\n\n  function get($key) {\n    $key = preg_replace('/_$/', '__', $key);\n    $key = preg_replace_callback('/[^a-z0-9_]/', 'self::encodeChar', $key);\n    return $GLOBALS[$key];\n  }\n\n  static function encodeChar($matches) {\n    return '«' . bin2hex($matches[0]) . '»';\n  }\n\n}\n\nclass Arr extends Object implements JsonSerializable {\n  public $className = \"[object Array]\";\n\n  static $protoObject = null;\n\n  function __construct() {\n    parent::__construct();\n    $this->setProto(self::$protoObject);\n    $args = func_get_args();\n    if (count($args) > 0) {\n      $this->_init($args);\n    } else {\n      $this->data->length = new Property(0.0, true, false, false);\n    }\n  }\n\n  function _init($arr) {\n    $len = count($arr);\n    for ($i = 0; $i < $len; $i++) {\n      $this->data->{$i} = new Property($arr[$i]);\n    }\n    $this->data->length = new Property((float)$len, true, false, false);\n  }\n\n  function push($value) {\n    $i = $this->data->length->value;\n    $this->data->{$i} = new Property($value);\n    return ($this->data->length->value = $i + 1);\n  }\n\n  static function checkInt($s) {\n    if (is_int($s) && $s >= 0) return (float)$s;\n    $s = to_string($s);\n    $match = preg_match('/^\\d+$/', $s);\n    return ($match !== false) ? (float)$s : null;\n  }\n\n  static function initProtoObject() {\n    $methods = array(\n      'push' => function($this_, $arguments, $value) {\n        //this is a special case, we have a low-level method\n        $this_->push($value);\n        return $this_->get('length');\n      },\n      'pop' => function($this_) {\n        $i = $this_->data->length->value - 1;\n        $result = $this_->get($i);\n        unset($this_->data->{$i});\n        $this_->data->length->value = $i;\n        return $result;\n      },\n      'join' => function($this_, $arguments, $str = ',') {\n        $results = array();\n        $len = $this_->data->length->value;\n        for ($i = 0; $i < $len; $i++) {\n          $results[] = to_string($this_->get($i));\n        }\n        return join($str, $results);\n      },\n      'toString' => function($this_) {\n        return $this_->callMethod('join');\n      }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setMethods($methods);\n  }\n\n  function set($key, $value) {\n    $i = self::checkInt($key);\n    if ($i !== null && $i >= $this->data->length->value) {\n      $this->data->length->value = $i + 1;\n    }\n    parent::set($key, $value);\n  }\n\n  function set_length($len) {\n    $len = self::checkInt($len);\n    if ($len === null) {\n      throw new Exception('RangeError: Invalid array length');\n    }\n    $oldLen = $this->data->length->value;\n    if ($oldLen > $len) {\n      for ($i = $len; $i < $oldLen; $i++) {\n        unset($this->data->{$i});\n      }\n    }\n    $this->data->length->value = $len;\n    return $len;\n  }\n\n  function jsonSerialize() {\n    $results = array();\n    $len = $this->data->length->value;\n    for ($i = 0; $i < $len; $i++) {\n      $results[] = $this->get($i);\n    }\n    return $results;\n  }\n}\n\nArr::initProtoObject();\n\nclass Date extends Object implements JsonSerializable {\n  public $className = \"[object Date]\";\n  public $value = null;\n  public $date = null;\n\n  static $LOCAL_TZ = null;\n  static $protoObject = null;\n\n  function __construct() {\n    parent::__construct();\n    $this->setProto(self::$protoObject);\n    $args = func_get_args();\n    if (count($args) > 0) {\n      $this->_init($args);\n    }\n  }\n\n  function _init($arr) {\n    $len = count($arr);\n    if ($len === 1) {\n      $value = $arr[0];\n      if (is_int_or_float($value)) {\n        $this->_initFromMiliseconds($value);\n      } else {\n        $this->_initFromString($value);\n      }\n    } else {\n      $this->_initFromParts($arr);\n    }\n  }\n\n  function _initFromMiliseconds($ms) {\n    $this->value = (float)$ms;\n    $this->date = self::fromValue($ms);\n  }\n\n  function _initFromString($str) {\n    $tz = (substr($str, -1) === 'Z') ? 'UTC' : null;\n    $arr = self::parse($str);\n    $this->_initFromParts($arr, $tz);\n  }\n\n  function _initFromParts($arr, $tz = null) {\n    //allow 0 - 6 parts; default to 0\n    for ($i = 0; $i <= 6; $i++) {\n      $arr[$i] = ($arr[$i] === null) ? 0 : $arr[$i];\n    }\n    $date = self::create($tz);\n    $date->setDate($arr[0], $arr[1] + 1, $arr[2]);\n    $date->setTime($arr[3], $arr[4], $arr[5]);\n    $this->date = $date;\n    $this->value = (float)($date->getTimestamp() * 1000 + $arr[6]);\n  }\n\n  function jsonSerialize() {\n    $date = self::fromValue($this->value, 'UTC');\n    $str = $date->format('Y-m-d\\TH:i:s');\n    $ms = '00' . ($this->value % 1000);\n    $ms = substr($ms, -3);\n    return $str . '.' . $ms . 'Z';\n  }\n\n  static function initProtoObject() {\n    $methods = array(\n      'valueOf' => function($this_) {\n        return $this_->value;\n      },\n      'toJSON' => function($this_) {\n        //2014-08-09T12:00:00.000Z\n        return $this_->jsonSerialize();\n      },\n      'toUTCString' => function($this_) {\n        //todo\n      },\n      'toString' => function($this_) {\n        //Sat Aug 09 2014 12:00:00 GMT+0000 (UTC)\n        return str_replace('~', 'GMT', $this_->date->format('D M d Y H:i:s ~O (T)'));\n      }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setMethods($methods);\n  }\n\n  static function create($tz = null) {\n    if ($tz === null) {\n      return new DateTime('now', new DateTimeZone(self::$LOCAL_TZ));\n    } else {\n      return new DateTime('now', new DateTimeZone($tz));\n    }\n  }\n\n  static function now() {\n    return floor(microtime(true) * 1000);\n  }\n\n  static function fromValue($ms, $tz = null) {\n    $timestamp = floor($ms / 1000);\n    $date = self::create($tz);\n    $date->setTimestamp($timestamp);\n    return $date;\n  }\n\n  static function parse($str) {\n    $str = to_string($str);\n    $d = date_parse($str);\n    //todo: validate $d for errors array and false values\n    return array($d['year'], $d['month'] - 1, $d['day'], $d['hour'], $d['minute'], $d['second'], floor($d['fraction'] * 1000));\n  }\n}\n\nDate::initProtoObject();\n\n//get the local timezone by looking for constant or environment variable; default to UTC\nDate::$LOCAL_TZ = defined('LOCAL_TZ') ? constant('LOCAL_TZ') : getenv('LOCAL_TZ');\nif (Date::$LOCAL_TZ === false) {\n  Date::$LOCAL_TZ = 'UTC';\n}\n\nclass RegExp extends Object implements JsonSerializable {\n  public $className = \"[object RegExp]\";\n\n  static $protoObject = null;\n\n  function __construct() {\n    parent::__construct();\n    $this->setProto(self::$protoObject);\n    $args = func_get_args();\n    if (count($args) > 0) {\n      $this->_init($args);\n    }\n  }\n\n  function _init($args) {\n    $this->source = ($args[0] === null) ? '(?:)' : to_string($args[0]);\n    $flags = ($args[1] === null) ? '' : to_string($args[1]);\n    $this->ignoreCase = (strpos($flags, 'i') !== false);\n    $this->global = (strpos($flags, 'g') !== false);\n    $this->multiline = (strpos($flags, 'm') !== false);\n  }\n\n  static function initProtoObject() {\n    $methods = array(\n      'exec' => function($this_, $arguments, $str) {\n        $str = to_string($str);\n        $result = preg_match($this_->callMethod('toString'), $str, $matches);\n        if ($result === false) {\n          return Null::$null;\n        }\n        $this_->set('lastIndex', (float)($result + strlen($matches[0])));\n        $arr = new Arr();\n        $arr->_init($matches);\n        $arr->set('index', (float)$result);\n        $arr->set('input', $str);\n        return $arr;\n      },\n      'test' => function($this_, $arguments, $str) {\n        $result = preg_match($this_->callMethod('toString'), to_string($str));\n        return ($result !== false);\n      },\n      'toString' => function($this_) {\n        $source = $this_->get('source');\n        $flags = '';\n        if ($this_->get('ignoreCase')) $flags .= 'i';\n        if ($this_->get('global')) $flags .= 'g';\n        if ($this_->get('multiline')) $flags .= 'm';\n        return '/' . str_replace('/', '\\\\/', $source) . '/' . $flags;\n      }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setMethods($methods);\n  }\n\n  function get_source() {\n    return $this->source;\n  }\n\n  function set_source($value) {\n    return $value;\n  }\n\n  function get_ignoreCase() {\n    return $this->ignoreCase;\n  }\n\n  function set_ignoreCase($value) {\n    return $value;\n  }\n\n  function get_global() {\n    return $this->global;\n  }\n\n  function set_global($value) {\n    return $value;\n  }\n\n  function get_multiline() {\n    return $this->multiline;\n  }\n\n  function set_multiline($value) {\n    return $value;\n  }\n\n  function jsonSerialize() {\n    return new StdClass();\n  }\n}\n\nRegExp::initProtoObject();\n\nclass Str extends Object {\n  public $className = \"[object String]\";\n  public $value = null;\n\n  static $protoObject = null;\n\n  function __construct($str = null) {\n    parent::__construct();\n    $this->setProto(self::$protoObject);\n    if (func_num_args() === 1) {\n      $this->value = $str;\n    }\n  }\n\n  static function initProtoObject() {\n    $methods = array(\n      'charAt' => function($this_, $arguments, $i) {\n        $ch = mb_substr($this_->value, 0, 1, 'utf-8');\n        return ($ch === false) ? '' : $ch;\n      },\n      'charCodeAt' => function($this_, $arguments, $i) {\n        $ch = mb_substr($this_->value, 0, 1, 'utf-8');\n        return ($ch === false) ? NaN::$nan : ord($ch);\n      },\n      'valueOf' => function($this_) {\n        return $this_->value;\n      },\n      'toString' => function($this_) {\n        return $this_->value;\n      }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setMethods($methods);\n  }\n}\n\nStr::initProtoObject();\n\nclass Number extends Object {\n  public $className = \"[object Number]\";\n  public $value = null;\n\n  static $protoObject = null;\n\n  function __construct($value = null) {\n    parent::__construct();\n    $this->setProto(self::$protoObject);\n    if (func_num_args() === 1) {\n      $this->value = (float)$value;\n    }\n  }\n\n  static function initProtoObject() {\n    $methods = array(\n      'valueOf' => function($this_) {\n        return $this_->value;\n      },\n      'toString' => function($this_, $arguments, $radix = null) {\n        //todo: radix\n        return to_string($this_->value);\n      }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setMethods($methods);\n  }\n}\n\nNumber::initProtoObject();\n\nclass Bln extends Object {\n  public $className = \"[object Boolean]\";\n  public $value = null;\n\n  static $protoObject = null;\n\n  function __construct($str = null) {\n    parent::__construct();\n    $this->setProto(self::$protoObject);\n    if (func_num_args() === 1) {\n      $this->value = $str;\n    }\n  }\n\n  static function initProtoObject() {\n    $methods = array(\n      'valueOf' => function($this_) {\n        return $this_->value;\n      },\n      'toString' => function($this_) {\n        return to_string($this_->value);\n      }\n    );\n    self::$protoObject = new Object();\n    self::$protoObject->setMethods($methods);\n  }\n}\n\nBln::initProtoObject();\n\n$Object = call_user_func(function() {\n  $Object = new Func(function($this_) {\n    return new Object();\n  });\n  $Object->set('prototype', Object::$protoObject);\n  //define \"static\" methods\n  $methods = array(\n    'create' => function($this_, $arguments, $proto) {\n      $obj = new Object();\n      $obj->setProto($proto);\n      return $obj;\n    },\n    'keys' => function($this_, $arguments, $obj) {\n      //todo: if (!($obj instanceof Object)) throw new Exception();\n      $results = new Arr();\n      foreach ($obj->data as $key => $prop) {\n        if ($prop->enumerable) {\n          $results->push($key);\n        }\n      }\n      return $results;\n    },\n    'getOwnPropertyNames' => function($this_, $arguments, $obj) {\n      //todo: if (!($obj instanceof Object)) throw new Exception();\n      $results = new Arr();\n      foreach ($obj->data as $key => $prop) {\n        $results->push($key);\n      }\n      return $results;\n    },\n    'getOwnPropertyDescriptor' => function($this_, $arguments, $obj, $key) {\n      //todo: if (!($obj instanceof Object)) throw new Exception();\n      $result = $obj->get($key);\n      return ($result) ? $result->getDescriptor() : null;\n    },\n    'defineProperty' => function($this_, $arguments, $obj, $key, $desc) {\n      //todo: if (!($obj instanceof Object)) throw new Exception();\n      $value = $desc->get('value');\n      $writable = $desc->get('writable');\n      if ($writable === null) $writable = true;\n      $enumerable = $desc->get('enumerable');\n      if ($enumerable === null) $enumerable = true;\n      $configurable = $desc->get('configurable');\n      if ($configurable === null) $configurable = true;\n      $obj->data->{$key} = new Property($value, $writable, $enumerable, $configurable);\n    },\n    'defineProperties' => function($this_, $arguments, $obj, $items) use (&$methods) {\n      //todo: if (!($obj instanceof Object)) throw new Exception();\n      foreach ($items->data as $key => $prop) {\n        if ($prop->enumerable) {\n          $methods['defineProperty'](null, null, $obj, $key, $prop->value);\n        }\n      }\n    }\n  );\n  $Object->setMethods($methods);\n  return $Object;\n});\n$Array = call_user_func(function() {\n  $Array = new Func(function($this_, $arguments, $value) {\n    $arr = new Arr();\n    $len = $arguments->get('length');\n    if ($len === 1.0 && is_int_or_float($value)) {\n      $arr->set('length', (float)$value);\n    } elseif ($len > 1) {\n      $arr->_init($arguments->args);\n    }\n    return $arr;\n  });\n  $Array->set('prototype', Arr::$protoObject);\n  //define \"static\" methods\n  $methods = array(\n    'isArray' => function($this_, $arguments, $arr) {\n      return ($arr instanceof Arr);\n    }\n  );\n  $Array->setMethods($methods);\n  return $Array;\n});\n$Date = call_user_func(function() {\n  $Date = new Func(function($this_, $arguments) {\n    $date = new Date();\n    $date->_init($arguments->args);\n    return $date;\n  });\n  $Date->set('prototype', Date::$protoObject);\n  //define \"static\" methods\n  $methods = array(\n    'now' => function($this_) {\n      return Date::now();\n    },\n    'parse' => function($this_, $arguments, $str) {\n      $date = new Date($str);\n      return $date->value;\n    },\n    'UTC' => function($this_, $arguments) {\n      $date = new Date();\n      $date->_initFromParts($arguments->args, 'UTC');\n      return $date->value;\n    }\n  );\n  $Date->setMethods($methods);\n  return $Date;\n});\n$RegExp = call_user_func(function() {\n  $RegExp = new Func(function($this_, $arguments) {\n    $reg = new RegExp();\n    $reg->_init($arguments->args);\n    return $reg;\n  });\n  $RegExp->set('prototype', RegExp::$protoObject);\n  return $RegExp;\n});\n$String = call_user_func(function() {\n  $String = new Func(function($this_, $arguments, $value) {\n    if ($this_ instanceof Str) {\n      $this_->value = to_string($value);\n    } else {\n      return to_string($value);\n    }\n  });\n  $String->instantiate = function() {\n    return new Str();\n  };\n  $String->set('prototype', RegExp::$protoObject);\n  //define \"static\" methods\n  $methods = array(\n    'fromCharCode' => function($this_, $arguments, $code) {\n      return chr($code);\n    }\n  );\n  $String->setMethods($methods);\n  return $String;\n});\n$Number = call_user_func(function() {\n  $Number = new Func(function($this_, $arguments, $value) {\n    if ($this_ instanceof Number) {\n      $this_->value = to_number($value);\n    } else {\n      return to_number($value);\n    }\n  });\n  $Number->instantiate = function() {\n    return new Number();\n  };\n  $Number->set('prototype', Number::$protoObject);\n  //define \"static\" methods\n  $Number->set('parseInt', new Func(function($this_, $arguments, $value, $radix = null) {\n    $value = to_string($value);\n    $value = preg_replace('/^[\\\\t\\\\x0B\\\\f \\\\xA0\\\\r\\\\n]+/', '', $value);\n    $sign = ($value[0] === '-') ? -1 : 1;\n    $value = preg_replace('/^[+-]/', '', $value);\n    if ($radix === null && strtolower(substr($value, 0, 2)) === '0x') {\n      $radix = 16;\n    }\n    if ($radix === null) {\n      $radix = 10;\n    } else {\n      $radix = to_number($radix);\n      if ($radix === NaN::$nan || $radix < 2 || $radix > 36) {\n        return NaN::$nan;\n      }\n    }\n    if ($radix === 10) {\n      return preg_match('/^[0-9]/', $value) ? (float)(intval($value) * $sign) : NaN::$nan;\n    } elseif ($radix === 16) {\n      $value = preg_replace('/^0x/i', '', $value);\n      return preg_match('/^[0-9a-f]/i', $value) ? (float)(hexdec($value) * $sign) : NaN::$nan;\n    } elseif ($radix === 8) {\n      return preg_match('/^[0-7]/', $value) ? (float)(octdec($value) * $sign) : NaN::$nan;\n    }\n    $value = strtoupper($value);\n    $len = strlen($value);\n    $numValidChars = 0;\n    for ($i = 0; $i < $len; $i++) {\n      $n = ord($value[$i]);\n      if ($n >= 48 && $n <= 57) {\n        $n = $n - 48;\n      } elseif ($n >= 65 && $n <= 90) {\n        $n = $n - 55;\n      } else {\n        $n = 36;\n      }\n      if ($n < $radix) {\n        $numValidChars += 1;\n      } else {\n        break;\n      }\n    }\n    if ($numValidChars > 0) {\n      $value = substr($value, 0, $numValidChars);\n      return floatval(base_convert($value, $radix, 10));\n    }\n    return NaN::$nan;\n  }));\n  $Number->set('parseFloat', new Func(function($this_, $arguments, $value) {\n    $value = to_string($value);\n    $value = preg_replace('/^[\\\\t\\\\x0B\\\\f \\\\xA0\\\\r\\\\n]+/', '', $value);\n    $sign = ($value[0] === '-') ? -1 : 1;\n    $value = preg_replace('/^[+-]/', '', $value);\n    if (preg_match('/^(\\d+\\.\\d*|\\.\\d+|\\d+)e([+-]?[0-9]+)/i', $value, $m)) {\n      return (float)($sign * $m[1] * pow(10, $m[2]));\n    }\n    if (preg_match('/^(\\d+\\.\\d*|\\.\\d+|\\d+)/i', $value, $m)) {\n      return (float)($m[0] * $sign);\n    }\n    return NaN::$nan;\n  }));\n  return $Number;\n});\n$Boolean = call_user_func(function() {\n  $Boolean = new Func(function($this_, $arguments, $value) {\n    if ($this_ instanceof Bln) {\n      $this_->value = $value ? true : false;\n    } else {\n      return $value ? true : false;\n    }\n  });\n  $Boolean->instantiate = function() {\n    return new Bln();\n  };\n  $Boolean->set('prototype', Bln::$protoObject);\n  return $Boolean;\n});\n$global = Object::$global = new GlobalObject();\n\n$escape = call_user_func(function() {\n  $list = array('%2A' => '*', '%2B' => '+', '%2F' => '/', '%40' => '@');\n  return new Func(function($global, $arguments, $str) use (&$list) {\n    $result = rawurlencode($str);\n    foreach ($list as $pct => $ch) {\n      $result = str_replace($pct, $ch, $result);\n    }\n    return $result;\n  });\n});\n\n$unescape = new Func(function($global, $arguments, $str) {\n  $str = str_replace('+', '%2B', $str);\n  return urldecode($str);\n});\n\n$encodeURI = call_user_func(function() {\n  $list = array('%21' => '!', '%27' => '\\'', '%28' => '(', '%29' => ')', '%2A' => '*', '%7E' => '~');\n  return new Func(function($global, $arguments, $str) use (&$list) {\n    $result = rawurlencode($str);\n    foreach ($list as $pct => $ch) {\n      $result = str_replace($pct, $ch, $result);\n    }\n    return $result;\n  });\n});\n\n$decodeURI = new Func(function($global, $arguments, $str) {\n  $str = str_replace('+', '%2B', $str);\n  return urldecode($str);\n});\n\n$encodeURIComponent = call_user_func(function() {\n  $list = array('%21' => '!', '%23' => '#', '%24' => '$', '%26' => '&', '%27' => '\\'', '%28' => '(', '%29' => ')', '%2A' => '*', '%2B' => '+', '%2C' => ',', '%2F' => '/', '%3A' => ':', '%3B' => ';', '%3D' => '=', '%3F' => '?', '%40' => '@', '%7E' => '~');\n  return new Func(function($global, $arguments, $str) use (&$list) {\n    $result = rawurlencode($str);\n    foreach ($list as $pct => $ch) {\n      $result = str_replace($pct, $ch, $result);\n    }\n    return $result;\n  });\n});\n\n$decodeURIComponent = new Func(function($global, $arguments, $str) {\n  $str = str_replace('+', '%2B', $str);\n  return urldecode($str);\n});\n\n$isNaN = new Func(function($global, $arguments, $value) {\n  return (to_number($value) === NaN::$nan);\n});\n\n$parseInt = $Number->get('parseInt');\n\n$parseFloat = $Number->get('parseFloat');\n\n$Math = call_user_func(function() {\n  $Math = new Object();\n\n  //constants\n  $Math->set('E', M_E);\n  $Math->set('LN10', M_LN10);\n  $Math->set('LN2', M_LN2);\n  $Math->set('LOG10E', M_LOG10E);\n  $Math->set('LOG2E', M_LOG2E);\n  $Math->set('PI', M_PI);\n  $Math->set('SQRT1_2', M_SQRT1_2);\n  $Math->set('SQRT2', M_SQRT2);\n\n  //private vars\n  $randMax = mt_getrandmax();\n\n  //Math.random()\n  $Math->set('random', new Func(function($this_) use (&$randMax) {\n    return (float)(mt_rand() / ($randMax + 1));\n  }));\n\n  //Math.round()\n  $Math->set('round', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return (float)round($num);\n  }));\n\n  //Math.ceil()\n  $Math->set('ceil', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return (float)ceil($num);\n  }));\n\n  //Math.floor()\n  $Math->set('floor', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return (float)floor($num);\n  }));\n\n  //Math.abs()\n  $Math->set('abs', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return (float)abs($num);\n  }));\n\n  //Math.max()\n  $Math->set('max', new Func(function($this_, $arguments) {\n    $args = $arguments->args;\n    $len = count($args);\n    $max = -INF;\n    for ($i = 0; $i < $len; $i++) {\n      $num = to_number($args[$i]);\n      if ($num === NaN::$nan) return NaN::$nan;\n      if ($num > $max) $max = $num;\n    }\n    return (float)$max;\n  }));\n\n  //Math.min()\n  $Math->set('min', new Func(function($this_, $arguments) {\n    $args = $arguments->args;\n    $len = count($args);\n    $min = INF;\n    for ($i = 0; $i < $len; $i++) {\n      $num = to_number($args[$i]);\n      if ($num === NaN::$nan) return NaN::$nan;\n      if ($num < $min) $min = $num;\n    }\n    return (float)$min;\n  }));\n\n  //Math.pow()\n  $Math->set('pow', new Func(function($this_, $arguments, $num, $exp) {\n    $num = to_number($num);\n    $exp = to_number($exp);\n    if ($num === NaN::$nan || $exp === NaN::$nan) {\n      return NaN::$nan;\n    }\n    return catch_nan(pow($num, $exp));\n  }));\n\n  //Math.log()\n  $Math->set('log', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(log($num));\n  }));\n\n  //Math.exp()\n  $Math->set('exp', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(exp($num));\n  }));\n\n  //Math.sqrt()\n  $Math->set('sqrt', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(sqrt($num));\n  }));\n\n  //Math.sin()\n  $Math->set('sin', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(sin($num));\n  }));\n\n  //Math.cos()\n  $Math->set('cos', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(cos($num));\n  }));\n\n  //Math.tan()\n  $Math->set('tan', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(tan($num));\n  }));\n\n  //Math.atan()\n  $Math->set('atan', new Func(function($this_, $arguments, $num) {\n    $num = to_number($num);\n    if ($num === NaN::$nan) return NaN::$nan;\n    return catch_nan(atan($num));\n  }));\n\n  //Math.atan2()\n  $Math->set('atan2', new Func(function($this_, $arguments, $y, $x) {\n    $y = to_number($y);\n    $x = to_number($x);\n    if ($y === NaN::$nan || $x === NaN::$nan) {\n      return NaN::$nan;\n    }\n    return catch_nan(atan2($y, $x));\n  }));\n\n  return $Math;\n});\n\n$JSON = call_user_func(function() {\n\n  $decode = function($value) use (&$decode) {\n    if ($value === null) {\n      return Null::$null;\n    }\n    $type = gettype($value);\n    if ($type === 'integer') {\n      return (float)$value;\n    }\n    if ($type === 'string' || $type === 'boolean' || $type === 'double') {\n      return $value;\n    }\n    if ($type === 'array') {\n      $result = new Arr();\n      $len = count($value);\n      for ($i = 0; $i < $len; $i++) {\n        $result->push($decode($value[$i]));\n      }\n    } else {\n      $result = new Object();\n      foreach ($value as $key => $item) {\n        $result->set($key, $decode($item));\n      }\n    }\n    return $result;\n  };\n\n  $parse = function($this_, $arguments, $string) use(&$decode) {\n    $value = json_decode($string);\n    return $decode($value);\n  };\n\n  $stringify = function($this_, $arguments, $value) {\n    return json_encode($value);\n  };\n\n  return new Object('parse', new Func($parse), 'stringify', new Func($stringify));\n});\n\n$console = call_user_func(function() {\n\n  $console = new Object();\n\n  $console->set('log', new Func(function($this_, $arguments) {\n    $len = $arguments->get('length');\n    $args = $arguments->args;\n    $output = array();\n    for ($i = 0; $i < $len; $i++) {\n      $output[] = to_string($args[$i]);\n    }\n    echo join(' ', $output) . \"\\n\";\n  }));\n\n  return $console;\n});\n\nclass Test {\n  static $stack = array();\n\n  static function suite($name, $fn) {\n    array_push(self::$stack, $name);\n    $fn(function($description, $condition) {\n      Test::assert($description, $condition);\n    });\n    array_pop(self::$stack);\n  }\n\n  static function assert($description, $condition) {\n    if ($condition instanceof Closure) {\n      $condition = $condition();\n    }\n    if ($condition !== true) {\n      $stack = array_slice(self::$stack, 0);\n      array_push($stack, $description);\n      throw new Exception('Test Failure: ' . join(': ', $stack));\n    }\n  }\n\n}\n\nclass Debug {\n\n  static function log() {\n    $args = func_get_args();\n    $len = count($args);\n    $output = array();\n    for ($i = 0; $i < $len; $i++) {\n      $output[] = self::stringify($args[$i]);\n    }\n    echo join(' ', $output) . \"\\n\";\n  }\n\n  static function dump() {\n    ob_start();\n    call_user_func_array('var_dump', func_get_args());\n    $output = ob_get_contents();\n    ob_end_clean();\n    $output = preg_replace('/\\n+$/', '', $output);\n    echo $output . \"\\n\";\n  }\n\n  static function keys($value) {\n    $keys = array();\n    foreach ($value as $key => $item) {\n      $keys[] = $key;\n    }\n    return join(\", \", $keys);\n  }\n\n  static function stringify($value) {\n    if ($value === null) {\n      return 'null';\n    }\n    $type = gettype($value);\n    if ($type === 'boolean') {\n      return $value ? 'true' : 'false';\n    }\n    if ($type === 'string' || $type === 'integer' || $type === 'double') {\n      return $value . '';\n    }\n    if ($type === 'array') {\n      //return '[object Array](' . count($value) . ')';\n      $len = count($value);\n      $output = array();\n      for ($i = 0; $i < $len; $i++) {\n        $output[] = self::stringify($value[$i]);\n      }\n      return '[object Array](' . $len . ')[' . join(', ', $output) . ']';\n    }\n    return '[object ' . get_class($value) . ']';\n  }\n\n}\n\n";
